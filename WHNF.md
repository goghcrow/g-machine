解释一下什么是 weak head norm form, 以及为什么叫这个名字 (DeepSeek)
---


# Weak Head Normal Form (WHNF) 的解释

**Weak Head Normal Form (WHNF)** 是 Haskell 等惰性（lazy）函数式编程语言中的一个重要概念，它表示一个表达式的**部分求值形式**，即表达式在**最外层**不再有可用的函数应用（redex, reducible expression），但内部可能仍然包含未求值的子表达式。

---

## 1. 什么是 WHNF？

一个表达式处于 WHNF 当且仅当它是以下情况之一：

1. **一个数据构造器（已部分或完全应用）**
    - 例如：`Just (1 + 2)` 是 WHNF，因为 `Just` 是一个构造器，即使 `(1 + 2)` 还未求值。
    - `(,) (1 + 1) (2 + 2)` 也是 WHNF，因为 `(,)` 是构造器，即使参数未求值。

2. **一个 lambda 抽象（未应用的函数）**
    - 例如：`\x -> x + 1` 已经是 WHNF，因为它是一个函数，不需要进一步求值（除非被应用）。

3. **一个部分应用的函数**
    - 例如：`(+) 1` 是 WHNF，因为它是一个部分应用的函数，等待第二个参数。

4. **一个未求值的 thunk（惰性计算的表达式）**
    - 例如：`let x = 1 + 2 in x` 中，`x` 是一个 thunk，但整个表达式是 WHNF，因为 `let` 绑定本身不强制求值。

---

### 什么不是 WHNF？

- **函数应用（尚未求值）**：`(\x -> x + 1) 5` 不是 WHNF，因为它可以进一步求值（变成 `6`）。
- **未匹配的 case 表达式**：`case Just 1 of { Nothing -> 0; Just x -> x }` 不是 WHNF，因为它需要模式匹配后才能确定形式。
- **未求值的算术运算**：`1 + 2` 不是 WHNF，因为它可以进一步计算成 `3`。

---

## 2. 为什么叫 "Weak Head Normal Form"？

这个名字可以从三个部分理解：

1. **Normal Form (NF)**
    - 在 λ 演算中，**Normal Form** 是指一个**完全求值**的表达式，无法再进一步化简。例如：
        - `1 + 2` 的 NF 是 `3`。
        - `(\x -> x + 1) 5` 的 NF 是 `6`。
    - 但在惰性语言中，我们通常不会完全求值，而是**按需计算**。

2. **Head Normal Form (HNF)**
    - 比 NF 弱一些，要求**最外层的构造器**已经确定，但内部可以未求值。
    - 例如：
        - `Just (1 + 2)` 是 HNF，因为 `Just` 是构造器。
        - `(,) (1 + 1) (2 + 2)` 也是 HNF。
    - 但 `\x -> x + 1` 不是 HNF（因为它不是构造器），而 `Just` 这样的构造器才是 "head"。

3. **Weak Head Normal Form (WHNF)**
    - 比 HNF 更宽松，允许**最外层是 lambda 或构造器**，而不仅仅是构造器。
    - 例如：
        - `\x -> x + 1` 是 WHNF（HNF 不认为它是，但 WHNF 允许）。
        - `Just (1 + 2)` 也是 WHNF。
    - 所以 "Weak" 表示比 HNF 更宽松的定义。

---